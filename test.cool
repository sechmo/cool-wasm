class TestClass inherits IO {
  someProp: IO <- out_string("testing"); 
  heyAnAttr: Int <- 32 + 21;
  aMethod(): TestClass {
    self
  };

  retInt(): Int {
    heyAnAttr
  };

  testLoop(someProp: Int): Int {
    let v: Int <- ~1, c: Int <- 0 in {
      while c < someProp loop 
        {c <- c + 1; v <- v * 2;}
      pool;
      v;
    }
  };
};

class A inherits IO {
  testMeth(): Object {
    {
      out_string("testMeth.A");
      testMeth();
    }
  };
};
class B inherits A {
  testMeth(): Object {
    out_string("testMeth.B")
  };
};


class C inherits B {
  testMeth(): Object {
    out_string("testMeth.C")
  };
  testLet(a: A, b: B, c: C, x: Int, s: String): Int {
    let a: Int <- x, x: String <- s in 
      {
        out_string(x);
        a;
      }
  };
};

class Main inherits IO{
  propI: Int <- 10;
  propS: String <- "Test";
  propNoInit: String;
  main(): Int {
    {"constant string";
    42; 
    propI; 
    -- out_int(20/3);
    8 + 19; 
    10 - 20; 
    20 * 15; 
    3 / 2;
    ~ 24 / 32 + 1 * (42 - ~ 9); -- 51
    if propI < 10 then 1 else 0 fi;  -- 0
    if propI <= 10 then 1 else 0 fi; -- 1
    if not 1 < ~1 then 1 else 0 fi; -- 1
    if not 1 <= 1 then 1 else 0 fi; -- 0
    if true then 1 else 0 fi; -- 1
    if false then 0 else 1 fi; -- 1
    new TestClass;
    new Int; -- 0
    if new Bool then 0 else 1 fi; -- 1
    (new C)@A.testMeth(); -- this should print first "testMeth.A" and then "testMeth.C"
    (new TestClass).retInt();
    let x: Int <- 999 in let propI: Int <- x in propI;
    let c: C <- new C in let c: Int <- c.testLet(c,c,c, 80, type_name()) in {c<- 99; c; }; -- should print "Main" and return 99
    {propS <- "cat"; propS.length(); }; -- 3
    (new TestClass).testLoop(5); -- ~32
    if isvoid propNoInit then 1 else 0 fi; -- 1
    }
  };
};